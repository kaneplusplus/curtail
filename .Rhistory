return((EY1Stop*pearly) + ((EY1Continue+EY2Continue)*(1-pearly))) #Eq. 7
}
expected_total_sample_size_Simon(p[2], nSimon, rSimon)
r <- rSimon
r <- r+1
z <- min(r[1], n[1]) : n[1]    # range of X1
pearly<- 1 - sum(dbinom(z, n[1], p))
pearly
expected_total_sample_size_Simon= function(p, n, r) {
r <- r+1
z <- min(r[1], n[1]) : n[1]    # range of X1
pearly<- 1 - sum(dbinom(z, n[1], p))
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
# Pr(Y1=y1|stop early)
# truncated negative binomial distribution
# number of trials until we reach n1-r1+1 failures
# n1-r1+1 <= y1 <= n1
prY1Stop <- function(y1, r1, n1, p1){
if(y1 < n1-r1+1 || y1 > n1 ){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-1-n1+r1)
denom <- sum(sapply((n1-r1+1):n1, function(j) factorial(j-1)/factorial(j-1-n1+r1) * p1^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
### expected value of Y1 | continue to Stage 2
EY1Continue <- sum(sapply(r[1]:n[1], function(i) i*prY1Continue(i, r[1], n[1], p)))
### expected value of Y1|stop early
EY1Stop <- sum(sapply((n[1]-r[1]+1):n[1], function(i) i*prY1Stop(i, r[1], n[1], p)))
### expected value of y2|continue to Stage 2
# i = possible values of y1
# j = possible values of x12
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
ey2 <-function(y1){
esnb(p, s = ifelse((r[2]-r[1])>0, (r[2]-r[1]), 0),
t = ifelse((n[2]+n[1]-y1-r[2]+r[1]+1)>0, n[2]+n[1]-y1-r[2]+r[1]+1, 0))
}
a <- py1*sapply(r[1]:n[1], function(y1) ey2(y1))
EY2Continue <- sum(a)
return((EY1Stop*pearly) + ((EY1Continue+EY2Continue)*(1-pearly))) #Eq. 7
}
p[2], nSimon, rSimon
expected_total_sample_size_Simon(p[2], nSimon, rSimon)
p
n
r
expected_total_sample_size_Simon(p, n, rSimon)
mean(simulation2[,"Y1"]+simulation2[, "Y2"])
expected_total_sample_size_Simon(0.45, nSimon, rSimon)
simonSim <- function(p, n, r, t, accrualRate)
# Simulate (Y1,Y2) curtailed sampling
# Returns (Y1, Y2, outcome) where outcome = 0 stopped early;
# 1 = accept H0; and 2 = reject H0.
{
r <- r+1
Y1 <- 0             # Stage 1 curtailed sample size
X1 <- 0             # Stage 1 successes
while (Y1 < n[1] && X1 < r[1] && (Y1 - X1) < (n[1] - r[1] + 1)){
Y1 <- Y1 +1       # One Stage 1 observation
X1 <- X1 + rbinom(n=1, size = 1, prob=p) # Their outcome
}
waitingTimes1 <- rexp(Y1, rate=accrualRate)
accrualTimes1 <- cumsum(waitingTimes1)
Stage1Duration <- accrualTimes1[Y1]+t[1]
if(X1 < r[1]) return(c(Y1, 0, 0, Stage1Duration, 0))  # Trial stops early
if(X1 >= r[2]) return(c(Y1, 0, 2, Stage1Duration, 0))
# Reject H0 with Stage 1 sample only
if((Y1 - X1) > (sum(n) - r[2]))  return(c(Y1, 0, 1, Stage1Duration, 0))  # Accept H0 with Stage 1 sample only
# in other words, if r2-X12 > n1+n2-Y1 we can't get the number of successes needed to reject H0
Y2 <- 0             # Stage 2 curtailed sample size
X2 <- 0
## this is correct
while(Y2 < (n[2]+(n[1]-Y1)) && (X1+X2<r[2]) && (Y2-X2)<(n[2]-r[2]+1+n[1]-Y1+X1) )
#(X12 + X2) > (Y1 + Y2 - sum(n) + r[2] -1) equivalent to (X12 + X2) > (Y2 - sum(n) + r[2] -1+Y1)
{
Y2 <- Y2 + 1                  # Generate a Stage 2 observation
X2 <- X2 + 1*rbinom(1, 1, p)
}
waitingTimes2 <- rexp(Y2, rate=accrualRate)
accrualTimes2 <- cumsum(waitingTimes2)
Stage2Duration <- accrualTimes2[Y2]+t[2]
if( X1 + X2 >= r[2]) return(c(Y1, Y2, 2, Stage1Duration, Stage2Duration)) # reject H0
else return (c(Y1, Y2, 1, Stage1Duration, Stage2Duration))   # accept H0
}
simulateSimonDesign <- function(p, n, r, t, accrualRate, nreps)
## simulates nrep trials
{
out <- matrix(NA, nrow=nreps, ncol=5)
## simulate the trial nrep times
for(i in 1:nreps){
out[i,] <- simonSim(p=p, n=n, r=r, t=t, accrualRate)  ## each simulation contains (Y1, Y2, outcome) where
## outcome = 0 stopped early; 1 = accept H0; and 2 = reject H0
## for each simulated trial
}
return(out)
}
accrualRate
accrualRate = 2
n <- c(19, 17)
p <- .2
r <- c(3, 10)
t <- 6
simulation2 <- simulateSimonDesign(p,n,r,t, accrualRate, nreps)
colnames(simulation2) <- c("Y1", "Y2", "Decision", "Stage1Duration", "Stage2Duration")
mean(simulation2[,"Stage1Duration"]+simulation2[,"Stage2Duration"])
X1
Y1
waitingTimes1 <- rexp(Y1, rate=accrualRate)
accrualTimes1 <- cumsum(waitingTimes1)
Stage1Duration <- accrualTimes1[Y1]+t[1]
Stage1Duration
Y2
waitingTimes2 <- rexp(Y2, rate=accrualRate)
accrualTimes2 <- cumsum(waitingTimes2)
Stage2Duration <- accrualTimes2[Y2]+t[2]
Stage2Duration
simonSim <- function(p, n, r, t, accrualRate)
# Simulate (Y1,Y2) curtailed sampling
# Returns (Y1, Y2, outcome) where outcome = 0 stopped early;
# 1 = accept H0; and 2 = reject H0.
{
r <- r+1
Y1 <- 0             # Stage 1 curtailed sample size
X1 <- 0             # Stage 1 successes
while (Y1 < n[1] && X1 < r[1] && (Y1 - X1) < (n[1] - r[1] + 1)){
Y1 <- Y1 +1       # One Stage 1 observation
X1 <- X1 + rbinom(n=1, size = 1, prob=p) # Their outcome
}
waitingTimes1 <- rexp(Y1, rate=accrualRate)
accrualTimes1 <- cumsum(waitingTimes1)
Stage1Duration <- accrualTimes1[Y1]+t
if(X1 < r[1]) return(c(Y1, 0, 0, Stage1Duration, 0))  # Trial stops early
if(X1 >= r[2]) return(c(Y1, 0, 2, Stage1Duration, 0))
# Reject H0 with Stage 1 sample only
if((Y1 - X1) > (sum(n) - r[2]))  return(c(Y1, 0, 1, Stage1Duration, 0))  # Accept H0 with Stage 1 sample only
# in other words, if r2-X12 > n1+n2-Y1 we can't get the number of successes needed to reject H0
Y2 <- 0             # Stage 2 curtailed sample size
X2 <- 0
## this is correct
while(Y2 < (n[2]+(n[1]-Y1)) && (X1+X2<r[2]) && (Y2-X2)<(n[2]-r[2]+1+n[1]-Y1+X1) )
#(X12 + X2) > (Y1 + Y2 - sum(n) + r[2] -1) equivalent to (X12 + X2) > (Y2 - sum(n) + r[2] -1+Y1)
{
Y2 <- Y2 + 1                  # Generate a Stage 2 observation
X2 <- X2 + 1*rbinom(1, 1, p)
}
waitingTimes2 <- rexp(Y2, rate=accrualRate)
accrualTimes2 <- cumsum(waitingTimes2)
Stage2Duration <- accrualTimes2[Y2]+t
if( X1 + X2 >= r[2]) return(c(Y1, Y2, 2, Stage1Duration, Stage2Duration)) # reject H0
else return (c(Y1, Y2, 1, Stage1Duration, Stage2Duration))   # accept H0
}
simulateSimonDesign <- function(p, n, r, t, accrualRate, nreps)
## simulates nrep trials
{
out <- matrix(NA, nrow=nreps, ncol=5)
## simulate the trial nrep times
for(i in 1:nreps){
out[i,] <- simonSim(p=p, n=n, r=r, t=t, accrualRate)  ## each simulation contains (Y1, Y2, outcome) where
## outcome = 0 stopped early; 1 = accept H0; and 2 = reject H0
## for each simulated trial
}
return(out)
}
simulation2 <- simulateSimonDesign(p,n,r,t, accrualRate, nreps)
colnames(simulation2) <- c("Y1", "Y2", "Decision", "Stage1Duration", "Stage2Duration")
mean(simulation2[,"Stage1Duration"]+simulation2[,"Stage2Duration"])
## prob y2 = 0 | continue to stage 2
prob2Simons <- function(p, n, r){
r <- r+1
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
return(ifelse(max(r[2]-r[1], 0)==0 | max(n[2]+n[1]-y1-r[2]+r[1]+1, 0)==0, 1, 0))
}
a <- sapply(r[1]:n[1], function(y1) sum(py1*y2(y1)))
return(sum(a))
}
prob2Simons(p, nSimon, rSimon)
critical_values(n = c(20, 5), p = c(.8, .2))
prob2Simons(p=.2, n=c(20, 5), r=c(14, 9))
csSimon <- function(){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop(p, n, r))*((1-prob2Simons(p, n, r))*t[2]))
}
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop(p, n, r))*((1-prob2Simons(p, n, r))*t[2]))
}
csSimon(p = .2, n=c(20, 5), r=c(14, 9), 6, accrualRate)
prob_early_stop_Simon <- function(p, n, r){
r <- r+1
z <- min(r[1], n[1]) : n[1]    # range of X1
pearly<- 1 - sum(dbinom(z, n[1], p))
return(pearly)
}
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop_Simon(p, n, r))*((1-prob2Simons(p, n, r))*t[2]))
}
csSimon(p = .2, n=c(20, 5), r=c(14, 9), 6, accrualRate)
p
n
n <- c(20, 5)
r <- c(14, 9)
t
expected_total_sample_size_Simon(p, n, r)
accrualRate
(1-prob_early_stop_Simon(p, n, r))
prob2Simons(p, n, r)
## prob y2 = 0 | continue to stage 2
prob2 <- function(p, n, r){
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
px12 <- sapply(0:r[1], function(j) dbinom(j, r[1], p[2]/p[1]))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
sapply(0:r[1], function(j) ifelse(max(r[2]-j, 0)==0 | max(n[2]+n[1]-y1-r[2]+j+1, 0)==0, 1, 0))
}
a <- sapply(r[1]:n[1], function(y1) sum(px12*y2(y1)))
pearly <- prob_early_stop( p, n, r)  # Probability of stopping early
return(sum(py1*a))
}
prob2(c(.8, .2), n, r)
## prob y2 = 0 | continue to stage 2
prob2 <- function(p, n, r){
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
px12 <- sapply(0:r[1], function(j) dbinom(j, r[1], p[2]/p[1]))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
sapply(0:r[1], function(j) ifelse(max(r[2]-j, 0)==0 | max(n[2]+n[1]-y1-r[2]+j+1, 0)==0, 1, 0))
}
a <- sapply(r[1]:n[1], function(y1) sum(px12*y2(y1)))
pearly <- prob_early_stop( p, n, r)  # Probability of stopping early
return(sum(py1*a))
}
prob2(c(.8, .2), n, r)
prob_early_stop_Simon(p, n, r)
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
py1
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
py1
a <- sum(sapply(r[1]:n[1], function(y1) py1*y2(y1)))
y2 <-function(y1){
return(ifelse(max(r[2]-r[1], 0)==0 | max(n[2]+n[1]-y1-r[2]+r[1]+1, 0)==0, 1, 0))
}
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
sapply(r[1]:n[1], function(y1) py1*y2(y1))
sapply(r[1]:n[1], function(y1) y2(y1))
a <- sum(py1*sapply(r[1]:n[1], function(y1) y2(y1)))
a
prob2Simons <- function(p, n, r){
r <- r+1
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
return(ifelse(max(r[2]-r[1], 0)==0 | max(n[2]+n[1]-y1-r[2]+r[1]+1, 0)==0, 1, 0))
}
a <- sum(py1*sapply(r[1]:n[1], function(y1) y2(y1)))
return(a)
}
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop_Simon(p, n, r))*((1-prob2Simons(p, n, r))*t[2]))
}
csSimon(p, c(20, 5), c(14, 9), 6, accrualRate)
1-prob2Simons(p, n, r)
expected_total_sample_size_Simon(p, n, r)
accrualRate
(1-prob_early_stop_Simon(p, n, r))
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop_Simon(p, n, r))*((1-prob2Simons(p, n, r))*t))
}
csSimon(p, c(20, 5), c(14, 9), 6, accrualRate)
(1-prob2Simons(p, n, r)
)
p
n
r
ph2simon(.2, .4, .1, .1)
ph2simon(.6, .8, .1, .1)
35-27
p <- .6
n <- c(27, 8)
r <- c(18, 24)
t <- 6
prob2Simons(p, n, r)
prob2Simons <- function(p, n, r){
r <- r+1
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
return(ifelse(max(r[2]-r[1], 0)==0 | max(n[2]+n[1]-y1-r[2]+r[1]+1, 0)==0, 1, 0))
}
a <- sum(py1*sapply(r[1]:n[1], function(y1) y2(y1)))
return(a)
}
(1-prob_early_stop_Simon(p, n, r))
prob_early_stop_Simon(p, n, r)
prob2Simons(p, n, r)
r
r <- r+1
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p[1]))
py1
#t <- n[2]+n[1]-i-r[2]+j+1
y2 <-function(y1){
return(ifelse(max(r[2]-r[1], 0)==0 | max(n[2]+n[1]-y1-r[2]+r[1]+1, 0)==0, 1, 0))
}
sapply(r[1]:n[1], function(y1) y2(y1))
r[2]-r[1]
r[2]
r
critical_values(n = c(20, 5), p = c(.8, .2))
prob2(p, n, r)
prob2Simons(p, n, r)
(1-prob2Simons(p, n, r)
)
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate+t+(1-prob_early_stop_Simon(p, n, r))*((1-prob2Simons(p, n, r))*t))
}
csSimon(p, c(20, 5), c(14, 9), 6, accrualRate)
csSimon(p, c(27, 8), c(18, 24), 6, accrualRate)
p
n
r
r <- r-1
r
simulation2 <- simulateSimonDesign(p,n,r,t, accrualRate, nreps)
colnames(simulation2) <- c("Y1", "Y2", "Decision", "Stage1Duration", "Stage2Duration")
mean(simulation2[,"Stage1Duration"]+simulation2[,"Stage2Duration"])
csSimon <- function(p, n, r, t, accrualRate){
return(expected_total_sample_size_Simon(p, n, r)/accrualRate + t + (1-prob_early_stop_Simon(p, n, r))*t)
}
csSimon(p, c(27, 8), c(18, 24), 6, accrualRate)
expected_total_sample_size_Simon= function(p, n, r) {
r <- r+1
z <- min(r[1], n[1]) : n[1]    # range of X1
pearly<- 1 - sum(dbinom(z, n[1], p))
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
# Pr(Y1=y1|stop early)
# truncated negative binomial distribution
# number of trials until we reach n1-r1+1 failures
# n1-r1+1 <= y1 <= n1
prY1Stop <- function(y1, r1, n1, p1){
if(y1 < n1-r1+1 || y1 > n1 ){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-1-n1+r1)
denom <- sum(sapply((n1-r1+1):n1, function(j) factorial(j-1)/factorial(j-1-n1+r1) * p1^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
### expected value of Y1 | continue to Stage 2
EY1Continue <- sum(sapply(r[1]:n[1], function(i) i*prY1Continue(i, r[1], n[1], p)))
### expected value of Y1|stop early
EY1Stop <- sum(sapply((n[1]-r[1]+1):n[1], function(i) i*prY1Stop(i, r[1], n[1], p)))
### expected value of y2|continue to Stage 2
# i = possible values of y1
# j = possible values of x12
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
ey2 <-function(y1){
esnb(p, s = ifelse((r[2]-r[1])>0, (r[2]-r[1]), 0),
t = ifelse((n[2]+n[1]-y1-r[2]+r[1]+1)>0, n[2]+n[1]-y1-r[2]+r[1]+1, 0))
}
a <- py1*sapply(r[1]:n[1], function(y1) ey2(y1))
EY2Continue <- sum(a)
print(esnb(p, r[1], n[1]-r[1]+1))
print((EY1Stop*pearly) + (EY1Continue*(1-pearly)))
return((EY1Stop*pearly) + ((EY1Continue+EY2Continue)*(1-pearly))) #Eq. 7
}
p
n
r
expected_total_sample_size_Simon(p, n, r)
(n[2]+n[1]-y1-r[2]+r[1]+1)
n
p
r
r <- r+1
z <- min(r[1], n[1]) : n[1]    # range of X1
pearly<- 1 - sum(dbinom(z, n[1], p))
#Pr(Y1=y1|continue to stage 2)
# truncated negative binomial distribution
# number of trials until we reach r1 successes
# r1 <= y1 <= n1
prY1Continue <- function(y1, r1, n1, p1){
if(y1<r1 || y1>n1){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-r1)
denom <- sum(sapply(r1:n1, function(j) factorial(j-1)/factorial(j-r1) *(1-p1)^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
# Pr(Y1=y1|stop early)
# truncated negative binomial distribution
# number of trials until we reach n1-r1+1 failures
# n1-r1+1 <= y1 <= n1
prY1Stop <- function(y1, r1, n1, p1){
if(y1 < n1-r1+1 || y1 > n1 ){
warning("Invalid parameter values")
return(NaN)
}
num <- factorial(y1-1)/factorial(y1-1-n1+r1)
denom <- sum(sapply((n1-r1+1):n1, function(j) factorial(j-1)/factorial(j-1-n1+r1) * p1^(j-y1)))
if(is.na(num/denom)){ return(0)}
return(num/denom)
}
### expected value of Y1 | continue to Stage 2
EY1Continue <- sum(sapply(r[1]:n[1], function(i) i*prY1Continue(i, r[1], n[1], p)))
### expected value of Y1|stop early
EY1Stop <- sum(sapply((n[1]-r[1]+1):n[1], function(i) i*prY1Stop(i, r[1], n[1], p)))
### expected value of y2|continue to Stage 2
# i = possible values of y1
# j = possible values of x12
py1 <- sapply(r[1]:n[1], function(i) prY1Continue(i, r[1], n[1], p))
#for the snb distribution,
#s <- r[2]-j
#t <- n[2]+n[1]-i-r[2]+j+1
ey2 <-function(y1){
esnb(p, s = ifelse((r[2]-r[1])>0, (r[2]-r[1]), 0),
t = ifelse((n[2]+n[1]-y1-r[2]+r[1]+1)>0, n[2]+n[1]-y1-r[2]+r[1]+1, 0))
}
a <- py1*sapply(r[1]:n[1], function(y1) ey2(y1))
EY2Continue <- sum(a)
print(esnb(p, r[1], n[1]-r[1]+1))
print((EY1Stop*pearly) + (EY1Continue*(1-pearly)))
(EY2Continue)*(1-pearly)
EY2Continue
EY1Continue
